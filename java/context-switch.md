## context switching이 필요한 이유

프로세서 코어 수가 스레드 수 보다 적거나 같다면 context switching이 일어날 필요가 없음(하나씩 할당하면 되니까)
그러나 현실적으로는 스레드 수가 프로세스 코어 수 보다 많아지게 되므로 이 한정된 프로세서 자원을 여러 스레드가 일정 시간을 갖고 돌아가면서 사용해야 하기 때문에 스케줄러가 실행중이던 스레드를 잠시 중단하고(이때 실행중이던 스레드의 컨텍스트를 어딘가에 저장해두어야 함) 다른 스레드로 전환하여 실행하는 것을 context switching이라고 함

>대부분의 context switching은 하드웨어 인터럽트, 그중에서도 타이머 인터럽트에 의해 발생하지만, 시스템 콜 호출같은 트랩(소프트웨어 이벤트)에 의해서도 발생할 수 있다.(커널 모드로 전환 후 다시 유저 모드로 복귀할 때 스케줄러에서 다른 스레드를 실행하도록 결정하면)

## 주소 공간

프로세스가 사용하는 물리적 메모리 공간을 가상 메모리 주소로 매핑할 때, 이 가상 메모리 공간을 효율적으로 관리하기 위해 OS가 제공하는 **논리적으로 추상화한 메모리 모델**
>이 모델은 **코드(Code)**, **데이터(Data)**, **힙(Heap)**, **스택(Stack)** 등으로 나뉘어 있으며(Linux OS 기준), 이러한 영역은 프로세스의 실행 및 데이터 관리를 위해 각각 고유한 역할을 수행

>주소 공간이라고 한다면 기본적으로 가상 메모리 주소를 사용한다고 생각하면 됨(가상 주소 공간)

각 프로세스는 독립적인 가상 주소 공간을 가지고, 이는 유저 공간과 커널 공간으로 나뉜다.
- 유저 공간: 각 프로세스가 서로 분리된, 독립적인 물리 메모리 공간을 사용
- 커널 공간: 프로세스 테이블같이 모든 프로세스가 공유하는 **코드와 데이터**가 있고 이는 물리 메모리에서 동일한 공간을 사용그러나 커널 스택의 경우 프로세스마다 독립적인 물리 메모리 공간을 사용

커널 공간은 커널이 관리하는 영역으로 유저가 임의로 접근할 수 없게 막는다. 인가에서 권한이 user이냐 admin이냐에 따라 다른 권한을 주는 것처럼 OS도 유저 모드와 커널 모드를 구분한다.

- 유저 모드: 애플리케이션(사용자 프로그램)이 실행될 때의 모드로, 커널 공간에 접근하거나 하드웨어를 직접 제어하는 행위를 제한
- 커널 모드: 하드웨어 및 커널 공간에 대한 모든 접근이 허용

커널 스택은 커널 공간에 존재하는 스택 영역으로 스레드마다 별도의 커널 스택을 가진다. 

## 스레드 컨텍스트 스위칭 vs 프로세스 컨텍스트 스위칭

스레드는 프로세스와 달리 **레지스터, 스택을 제외한 나머지 주소 공간을 공유**한다.
(스택의 경우 프로세스의 스택 영역을 나누어 각각 별도의 스택 영역을 할당받는다.)
따라서 스레드의 상태(정보)를 나타내는 TCB(thread control block)에도 스택 포인터 값은 저장하지만 특정 프로세스의 page table이 메모리의 어디에 위치하는지를 저장하는 page table base register 값은 저장하지 않는다. 
반면 프로세스 컨텍스트 스위칭은 주소 공간 자체가 바뀌기 때문에 CPU 캐시가 참조하는 주소 공간도 달라져야 하므로 캐시 플러싱이 발생한다.
>참고로 page table은 OS가 관리하는 커널 공간에 존재한다. 속도를 위해 자주 사용되는 page table entry는 TLB라는 캐시에 저장해두는데, 프로세스 컨텍스트 스위칭이 일어나면 page table도 변경해야 하므로 TLB도 플러싱해야 한다.

스레드 컨텍스트 스위칭을 위해선 TCB를 메모리 어딘가에 저장해두고 블로킹 상태로 전환했다가 다시 실행되게 되면 이를 가져와 마지막으로 실행되었던 상태를 그대로 복원해야 한다.
>TCB는 tid, PC 레지스터 값, 스레드 상태, stack pointer(esp 레지스터) 값 등에 대한 정보를 가진다.

이때 스레드가 유저 레벨 스레드 이냐 커널 레벨 스레드이냐에 따라 상황이 다르다.

### 커널 레벨 스레드(KLT)

- 커널이 직접 생성하고 관리하는 스레드
- OS 스케줄러가 스케줄링을 수행
- TCB를 커널 스택에 저장
>커널이 개별적인 스레드를 전부 알고 있기 때문에 KLT 중 하나가 블로킹되어도 해당 스레드가 속한 프로세스 내 다른 스레드들은 계속 스케줄링 되어 실행될 수 있다.

### 유저 레벨 스레드(ULT)

- 애플리케이션 내부의 스레드 라이브러리가 스케줄링을 수행
> OS 스케줄러가 스레드 스케줄링을 담당하지 않으므로 OS 레벨에선 ULT의 존재를 모르고 그냥 하나의 단일 프로세스가 있다고 생각함. 따라서 ULT중 하나가 system call 호출 시 해당 ULT가 속한 프로세스 자체가 블로킹되기 때문에 나머지 ULT들도 같이 블로킹 되어 스케줄링 될 수 없음
> 따라서 ULT는 블로킹 작업(ex. IO작업)을 최대한 피하고 논블로킹 IO 를 사용하는 방식으로 설계되는 경우가 많다고 하는데...이 부분이 event driven 모델(ex. netty)이 주목받는 이유 중 하나이지 않을까

- TCB를 커널 스택에 저장하지 않고 유저 공간의 스레드 라이브러리에 저장

>TCB와 스케줄링 모두 유저 공간의 스레드 라이브러리에서 관리하기 때문에 커널 모드로의 전환이 필요 없으므로 더 빠른 컨텍스트 스위칭이 가능하다 

처음에는 스위칭 주기만 같다면 결국 같은 시간 내에 스위칭 횟수는 같을거니까 컨텍스트 스위칭 비용이 똑같지 않을까 생각했다. 그러나 스레드가 많아지면 다음과 같은 요인들로 인해 결과적으로 스레드 컨텍스트 스위칭 비용이 늘어남

1. 컨텍스트 스위칭의 비용 자체가 늘어남
	- 스케줄링 오버헤드: 스레드가 많아질수록 스케줄러가 **우선순위를 계산하고 실행할 스레드를 선택하는 작업**이 더 복잡하고 시간이 오래 걸림

2. 컨텍스트 스위칭의 횟수가 빈번해짐
	- 동기화 문제: 스레드 간 동기화를 위해 락을 사용하게 되면 이로 인해 블로킹 상태로의 전환이 잦아지고 이는 컨텍스트 스위칭이 더 빈번해짐
	- 시간 분할: 스레드의 수가 많아질수록 스케줄러 입장에선 어쩔 수 없이 개별 스레드에 할당해 줄 수 있는 시간이 줄어들 수 밖에 없고, 이는 컨텍스트 스위칭을 더 빈번하게 일어나게 만듦


## JVM의 platform thread

**OS의 Kernel-Level Thread(KLT)와 1:1로 매핑된 유저 레벨 스레드**
>JVM이 OS의 KLT를 기반으로 구현한 스레드로, 각 자바 Thread 객체는 하나의 KLT에 매핑됨(one-to-one 관계)
>따라서 platform thread의 생성과 관리는 JVM 내부 로직을 시작되지만, 컨텍스트 스위칭을 OS 스케줄러가 처리하고, start(), sleep(), join()과 같은 메소드도 OS system call을 사용

>KLT와 1대1 관계이고 결국 모든 로직을 커널이 수행해야 하므로 커널 모드 진입이 필요하다면 굳이 왜 ULT가 필요한가를 고민했을 때...JVM의 경우 특정 OS에 구애받지 않고 여러 OS에서 자바를 실행시킬 수 있어야 하므로 이렇게 JVM 상에서 추상화한 Thread 객체를 제공하는 게 아닐까..

platform thread보다 경량화 된 ULT가 java virtual thread
## Java Virtual Thread

jdk21에 등장한 개념으로 기존 platform thread보다 가벼운 JVM상의 가상의 스레드(ULT)
>플랫폼 스레드 위에서 여러 가상 스레드가 번갈아 가며 실행되는 형태

결국 ULT(가상 스레드)와 KLT가 many-to-one 관계 형태가 되므로, 가상 스레드간의 컨텍스트 스위칭이 커널의 개입 없이 수행되기 때문에 가상 스레드의 컨텍스트 스위칭의 비용이 플랫폼 스레드의 컨텍스트 스위칭 비용보다 작음

아직 JVM을 계속 공부하는 단계라...이쪽은 헷갈리는게 넘 많아서 더 공부하고 좀 더 깊게 정리를 해야 할거 같습니다...

