JMM은 synchronized를 사용할 때 메모리 가시성(visibility)을 보장

• synchronized 블록에 진입하기 전에, 해당 스레드의 로컬 뷰는 메인 메모리와 동기화하여 로컬 뷰에 저장된 변수 값이 메인 메모리의 최신 값인지 확인
• synchronized 블록을 빠져나올 때도, 로컬 뷰에서 변경된 변수 값을 메인 메모리에 반영


## Monitor

semaphore의 경우 개발자가 직접 P(), V()(sema_up, down)를 사용해서 동기화 작업을 다루게 되면 실수할 가능성이 높기 때문에, 동시성 처리를 더 안전하고 편리하게 하기 위해 추상화하여 제공
`synchronized` 라는 추상화된 키워드를 통해 객체 단위로 존재하는 모니터를 사용하여 동시성 제어를 할 수 있음

## Mesa-style monitor vs Hoare-style monitor

모니터를 획득한 스레드가 임계 영역의 작업을 끝내고 모니터 락 획득을 해제해야 할때, 
조건 변수 wait set에서 블로킹 상태로 대기하고 있던 스레드를 깨우는 작업과 락 획득을 해제하는 작업을 어떻게 수행할 것이냐에 따라 상황이 달라진다.

1. 스레드 깨우기 -> 락 획득 해제
이 경우 조건을 만족하여 깨어난 스레드가 실행되어 락을 획득하려 할때 아직 해당 스레드를 깨운 스레드에서 락을 놓아주지 않았을 수 있다.
> 이 방식이 mesa style로 위 문제를 해결하기 위해 신호를 받은 스레드가 깨어나서(Runnable 상태로 전환) 즉시 컨텍스트 스위칭되어 락 획득을 시도하는게 아니라 블로킹 상태(sleep) 그대로 entry set으로 일단 이동하여 대기했다가 실제로 락이 해제되는 시점에 entry set에 있던 스레드를 깨워 실행되고 락 획득 시도
> Runnable로 상태를 전환하지 않는 이유는 그렇게 되면 OS 스케줄러가 컨텍스트 스위칭을 통해 해당 스레드에게 CPU 자원을 쥐어줄 수 있는데(실행될 수 있는데) 막상 락이 해제되지 않은 상황이면 해당 스레드가 할 수 있는게 없고 다시 wait 해야 하기 때문

entry set에서 대기하던 중에 락을 획득할 수 있는 조건이 변경될 수 있으므로 락을 획득한 후에도 조건이 여전히 충족되는지 확인하기 위해 **조건 재확인**이 필수이다.
>이때 조건을 체크하여 만족하지 않으면 다시 wait하고 나중에 깨워지면 다시 조건을 체크해야 하므로 if문이 아닌 while문을 사용해야 한다.

>여기서 헷갈렸던게...난 처음에 조건 변수가 그냥 wait set이랑 같은 개념이라고 생각했는데 그게 아니라 조건 변수는 락을 획득하여 임계 영역에 들어간 상황에서 조건이 충족되었는지 체크할 수 있게 하기 위해 존재
>좀 더 자세히 설명하면 예를 들어 생산자-소비자 문제처럼 락 획득 후 버퍼에 프로듀서가 생산한 엔트리가 있는지 체크하는 것 처럼 공유 자원의 상태를 기준으로 스레드의 실행을 제어하기 위해 존재하는 것이 조건 변수
>
>반드시 락을 획득한 후에 조건 변수를 체크해야 하는게 그렇지 않으면 조건을 검사하는 동안 다른 스레드에서 조건의 상태를 변경하여 동시성 문제가 발생할 수 있기 때문

2. 락 획득 해제 -> 스레드 깨우기
이 경우 락을 놓아준 시점과 깨워진 스레드가 락을 획득 시도하는 시점 사이에 텀이 있기 때문에 
(원자적으로 수행되는것이 아니기 때문에) 마찬가지로 그 사이에 락을 획득할 수 있는 조건이 변경될 수 있으므로 깨어난 스레드가 락을 획득하려 하는 시점에 다시 한번 조건을 체크해야 함
>여기서 말하는 조건이 변경될 수 있다는 것 중의 하나는 그 사이에 늦게 모니터 락 획득을 시도한 다른 스레드가 얌체같이 락을 가져가는 상황이 될 수 있음

이렇게 특정 스레드가 더 먼저 오랫동안 락을 획득하기 위해 대기했지만 늦게 모니터 락 획득을 시도한 다른 스레드가 운좋게 모니터 락 해제 타이밍과 맞아서 얌체같이 락을 채가는 공평성의 문제가 발생할 수 있기 때문에 먼저 대기한 스레드가 먼저 모니터를 획득할 수 있도록 하려면 FIFO 구조의 큐 형태를 사용해서 head node부터 모니터를 획득할 수 있도록 해야한다.

ReentrantLock의 경우 boolean 타입 인자를 true로 넘기면 락이 해제되었을 때 대기 큐의 맨 앞에 있는 스레드가 우선적으로 락을 획득하는 공정 모드로 적용된다.
`ReentrantLock lock = new ReentrantLock(true);`
> 그러나 유의해야 할 점이 공정하다는게 성능이 더 뛰어나다는 것은 아니다. 새치기가 허용되는 비공정한 상황이 공정한 상황보다 성능적으로 더 뛰어날 수 있다.

3. 락 획득 해제와 스레드 깨우기를 원자적으로 수행
이 방식이 Hoare-style로 락 획득 전에 조건이 변경되는 상황은 발생하지 않으므로 while문으로 조건을 체크할 필요가 없다.

>hoare-style이 더 효율적인거 같은데 mesa-style을 사용하는 이유를 gpt한테 물어봤을 때 mesa style은 hoare-style보다 컨텍스트 스위칭 하는 횟수를 더 줄일 수 있어서 더 효율적이라고 하는데 이해가 잘 안감...
>Hoare-style로 락 획득 전에 조건이 변경되는 상황은 발생하지 않으므로 while문으로 조건을 체크할 필요가 없으면 스레드를 깨우기만 하는게 아니라 컨텍스트 스위칭까지 하더라도 해당 스레드가 다시 wait 할 일은 없으니까 비효율적인 컨텍스트 스위칭이 발생하지 않는거 아닌가...구현이 더 어려운건 맞을거 같은데


## 번외: reentrantLock이 왜 필요한걸까(재진입이 필요한 이유)

```java
class ReentrantExample {
    public synchronized void methodA() {
        System.out.println("Method A is executing.");
        methodB(); // methodB도 동일한 락을 사용
    }

    public synchronized void methodB() {
        System.out.println("Method B is executing.");
    }
}
```
같은 객체의 모니터를 사용하기 때문에 methodA에서 이미 락을 잡은 상태에서 methodB를 호출하면 동일한 모니터에 대해 재진입을 하게 됨

>재진입이 허용되지 않으면, 스레드는 이미 소유한 락을 다시 획득하려다 **스스로를 블로킹**

블로킹 방식의 동기화는 컨텍스트 스위치 비용때문에 만약 락 획득과 해제 사이의 텀이 길지 않다면 컨텍스트 스위치를 하지 않고 CPU 자원을 점유한채로 락이 해제될 때 까지 대기하는 스핀 락이 더 효율적인 상황도 있습니다.
>텀이 길어진다면 컨텍스트 스위치 비용보다 해당 스레드가 CPU 자원을 점유함에 따라 다른 스레드가 작업을 하지 못하는 비용이 더 커서 블로킹 방식보다 비효율적일 수 있다.
