# Tomcat 요청 처리 흐름

## Thread Pool

톰캣은 다중 요청을 처리하기 위해 부팅 시 쓰레드 풀을 생성합니다.

이때, 쓰레드 풀이란 쓰레드들을 미리 생성해 놓은 집합 저장소입니다.

## 톰캣의 요청 처리 흐름

#### 요청이 들어오면

1. 클라이언트로부터 받은 요청에 대한 커넥션 객체를 **작업 큐**에 넣어둡니다.
    - 첫 요청에는 별도의 설정이 없다면 기본적으로 CPU 코어수만큼의 쓰레드를 생성해 쓰레드풀에 넣어둡니다.
2. 그리고 쓰레드 풀에서 사용가능한 쓰레드를 꺼내 작업 큐에 넣어둔 요청을 처리합니다.
3. 작업이 끝난 후에 쓰레드는 다시 작업 가능한 상태로 반환됩니다.
    - 이때, 작업 큐가 비어있는데 초기 설정값보다 많은 수의 쓰레드가 쓰레드풀에 존재한다면 제거 됩니다.

#### 작업 큐가 가득 찬다면

- 설정한 Max > 현재 쓰레드 수
    
    → 새로 생성해 작업을 보다 빠르게 처리
    
- 설정한 Max == 현재 쓰레드 수
    
    → 작업 큐 크기를 초과하는 요청에 대해 refuse
    

---

# Connector

### Connector란?

- 톰캣에서 클라이언트와 서버간의 통신을 관리합니다.

#### 요청 처리

1. 클라이언트의 요청을 수신해 HttpServletRequest로 변환합니다.
2. HttpServletRequest를 적절한 서블릿 컨테이너로 전달합니다.

## BIO (Blocking I/O)

#### 특징

- 특정 커넥션이 닫힐 때까지 하나의 Thread는 특정 커넥션이 종료될 때까지 할당됩니다.
- 즉, 요청 처리 중 쓰레드가 블로킹 상태가 될 수 있습니다.

## NIO (New I/O)

#### 특징

- 바로 새로운 쓰레드에 할당하지 않고, Poller 라는 별도의 쓰레드가 커넥션을 처리합니다.

### Poller 쓰레드

- Poller는 Socket들을 캐시에 들고 있다가 해당 Socket 데이터에 대한 처리가 가능한 순간에만 쓰레드를 할당하는 방식을 사용합니다.
- Poller에선 max connection까지 연결을 수락하고, 작업큐 사이즈와 관계 없이 캐싱 기능을 활용하므로 하나의 쓰레드에 대해 더 많은 커넥션 연결을 유지할 수 있습니다.
- 물론 너무 많은 요청이 몰려서 최대 대기큐의 사이즈를 넘어서면 커넥션을 refuse 하는것은 동일합니다.


---

참고 자료

https://haon.blog/haon/spring/tomcat-concept/

[https://velog.io/@cjh8746/아파치-톰캣의-NIO-Connector-와-BIO-Connector에-대해-알아보자](https://velog.io/@cjh8746/%EC%95%84%ED%8C%8C%EC%B9%98-%ED%86%B0%EC%BA%A3%EC%9D%98-NIO-Connector-%EC%99%80-BIO-Connector%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

https://velog.io/@jihoson94/BIO-NIO-Connector-in-Tomcat